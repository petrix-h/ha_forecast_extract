# Originally based on: https://gist.github.com/JohanAlvedal/48fb8b3e1ef5fc3a70b5c473be54e2fe
blueprint:
  name: Extract 24 Hourly Temperature and Datetime
  description: >
    Fetches the next 24 hours of temperature forecasts from the forecast wether entity. 
    parses the lowest temperature for the next 24h and saves it in the designated temperature helper.
    Additinally the datetime timestamp for the lowest temperature is stored in another helper for datetime.
    Finally the interval is configurable by the minute pattern. 
  domain: automation
  input:
    # The input weather data
    weather_entity:
      name: Weather Entity
      description: Select the weather entity to extract hourly temperature forecasts from. Tested and verified with SMHI and Met.no weather integrations.
      selector:
        entity:
          domain: weather
      default: weather.forecast_home
    
    #The target helper entities
    target_min_temp:
      name: Target Min Temp
      description: The input_number entity where the lowest temperature for the next 24h will be stored
      selector:
        entity:
          domain: input_number
      default: input_number.min_temp_next_24h
    target_min_temp_date:
      name: Target Min Temp Date
      description: The input_datetime entity where the timestamp for the lowest temperature in the next 24h will be stored
      selector:
        entity:
          domain: input_datetime
      default: input_datetime.min_temp_24h_date_time
    target_forecast_data:
      name: Target Forecast Data
      description: The input_text entity where the 24h forecast data will be stored as JSON
      selector:
        entity:
          domain: input_text
      default: input_text.forecast_24h_data

    # The update interval 
    interval_pattern:
      name: Update Interval Pattern (minutes)
      description: >
        Specify a time pattern value for minutes. Examples:
        "/30" (every 30 minutes), "0,30" (at :00 and :30), "15" (at :15 every hour).
        More frequent updates ensure fresher data but may increase system load.
      default: "01"
      selector:
        text:
          multiline: false

mode: single
max_exceeded: silent

variables:
  weather_eid: !input weather_entity
  target_min_temp: !input target_min_temp
  target_min_temp_date: !input target_min_temp_date
  target_forecast_data: !input target_forecast_data

triggers:
  - trigger: time_pattern
    minutes: !input interval_pattern
  - trigger: homeassistant
    event: start
  - trigger: event
    event_type: event_template_reloaded

actions:
  # Fetch hourly forecast using weather.get_forecasts
  - action: weather.get_forecasts
    data:
      type: hourly
    target:
      entity_id: "{{ weather_eid }}"
    response_variable: weather_response

  # Debug logging for raw weather response
  - action: system_log.write
    data:
      message: "Weather forecast response: {{ weather_response }}"
      level: info

  - variables:
      forecast_data: "{{ weather_response[weather_eid].forecast or [] }}"
      sorted_forecast: "{{ forecast_data | sort(attribute='datetime') }}"
      # list of first 24 forecast entries
      first24: >
        {{
          (sorted_forecast | list)[:24]
        }}
      # rounded temperatures for those entries
      temps: >
        {{
          (first24
          | map(attribute='temperature')
          | map('round', 1)
          | list)
        }}
      min_temperature: "{{ (temps | min) if (temps | length) > 0 else none }}"
      # find the first entry in first24 whose rounded temperature equals min_temperature, then take its datetime
      min_temperature_date: >
        {{
          (
            (first24
            | selectattr('temperature', 'defined')
            | selectattr('temperature', 'ne', none)
            | selectattr('temperature', 'equalto', min_temperature)
            | map(attribute='datetime')
            | list)[0]
          ) if (min_temperature is not none and (first24 | length) > 0) else none
        }}
      # create JSON structure with datetime and temperature for each forecast entry
      forecast_json: >
        {% set result = [] %}
        {% for item in first24 %}
          {% set result = result + [{'datetime': item.datetime, 'temperature': item.temperature}] %}
        {% endfor %}
        {{ result | tojson }}

  # Debug logging for forecast processing
  - action: system_log.write
    data:
      message: "Forecast data count: {{ forecast_data | length }}"
      level: info
  - action: system_log.write
    data:
      message: "First24 count: {{ first24 | length }}"
      level: info
  - action: system_log.write
    data:
      message: "Forecast JSON: {{ forecast_json }}"
      level: info

  # Debug logging to show old vs new values
  - action: system_log.write
    data:
      message: >
        Temperature update: 
        OLD TEMP: {{ states(target_min_temp) }}
        NEW TEMP: {{ min_temperature }}
        OLD DATE: {{ states(target_min_temp_date) }}
        NEW DATE: {{ min_temperature_date }}
      level: info

  # Save the temperature string to input_text entity
  - action: input_number.set_value
    target:
      entity_id: "{{ target_min_temp }}"
    data:
      value: "{{ min_temperature }}"
  # Save the temperature string to input_text entity
  - action: input_datetime.set_datetime
    target:
      entity_id: "{{ target_min_temp_date }}"
    data:
      timestamp: "{{ as_datetime(min_temperature_date).timestamp() | int  }}"
  # Save the forecast data as JSON
  - action: input_text.set_value
    target:
      entity_id: "{{ target_forecast_data }}"
    data:
      value: "{{ forecast_json }}"
